STATE

dev_lba_low, dev_lba_hi, os_lba_low, os_lba_hi, dev_sect : abs;
dev_st, os_st                                            : nonabs 5;

LABEL

class_lba_low, write8_arg, read_req_lba_low_arg, read_req_lba_hi_arg : abs;
cont, ctag, addr, class_sect_written, utag                           : nonabs 5;

INIT

dev_st==0 && os_st==0

GOAL

os_st==0

TRANS
{
    dev_lba_low := case {
        cont==1 && ctag==0 && addr==0 : write8_arg;
        true                       : os_lba_low;
    };

    dev_lba_hi := case {
        cont==1 && ctag==0 && addr==1 : dev_lba_low;
        true                       : dev_lba_hi;
    };

    dev_sect := case {
        cont==1 && ctag==0 && addr==2 : write8_arg;
        true                       : dev_sect;
    };

    /*

    dev_sect_finite : {udma_m1, udma_m2, other}
    write8_arg_dev_sect_fin : same as above
    will introduce preds such as write8arg==udma_m1 etc

    dev_sect_finite := case {
        cont==1 && ctag==0 && addr==2 : write8_arg_dev_sect_fin;
        true                       : dev_sect_finite;
    };

    */

    os_lba_low := case {
        cont==0 && utag==0 : read_req_lba_low_arg;
        true             : os_lba_low;
    };

    os_lba_hi := case {
        cont==0 && utag==0 : read_req_lba_hi_arg;
        true             : os_lba_hi;
    };

    dev_st := case {
        dev_st==0 : case {
            cont==1 && ctag==1 && addr==3  : 1;
            cont==0 && utag==1            : 2; //dev_impossible
            true                        : 0;
        };
        dev_st==1 : case {
            cont==0 && utag==1            : 0;
            true                        : 1;
        };
    };

    class_udma_mode_set := case {
        dev_st==0 && cont==1 && ctag==1 && addr==4 : 1;
        true                                    : 0;
    };

    class_udma_mode_val <= dev_sect;

    //class_sect_written <= if(utag==1){1}else{0};
    class_lba_low <= dev_lba_low;

    /*
    if(utag==1){
        {
            var1 <= 1;
            var2 <= 2;
            var3 := if(var1==var2) {1} else {0};
        }
    } else {
        {
            var1 <= 0;
            var2 <= 3;
            var3 := if(var1==var2) {1} else {0};
        }
    };
    */

    os_st := case {
        os_st==0 : case {
            cont==0 && class_sect_written==1 : 2; //error
            cont==0 && utag==2            : 1;
            true                        : 0;
        };
        os_st==1 : case {
            cont==0 && class_sect_written==1 && class_lba_low!=os_lba_low : 2;
            cont==0 && class_sect_written==1 && class_lba_low==os_lba_low : 0;
            true                                                     : 1;
        };
   };
}

/*
    goal : os_st==0 || dev_st==dev_impossible
*/

/*

--finding finite subdomain:

search for all preds
eg if variable is x and find x==1, x==5...
what if dev_sect has eq preds as well? - ignore
what if new preds appear when combining labels? 
    eg l==8, l==x, x==8


variables have some possibly infinite domain with some concrete elements eg 0, 1, 2, False, True

we want update functions for:
x==y 
x==c where c is an element of xs domain
maybe entire variable if it comes from a small domain and is only assigned similar variables

atoms in our language are: x==y, x==c and x which is the same as x/=0

depends on variable representation
x==c : entire domain of x represented?
x==y : entire domain of x and y represented?

conj {
    // Map String -> (abs1, passthrough)
    // map has z, x, y
    z <= f(..);
    --z <= f(x);
    case {
        a : {
                // Map String -> (ab1, passthrough)
                // map has x, y
                /*
                    a : maintain Map String -> CtrlExpr as source of signal
                    b : maintain a Map String -> (ab1, passthrough) as memo table
                    go through all signals assigned at this level or lower
                    
                */
                x <= f(y, z);
                y <= f(z)

                /*
                    dependencies: 
                    x -> [y, z]
                    y -> [z]
                    sort: [z, y, x]
                    Map String stuff -> (Map String stuff, [signals it depends on])
                */
            };
        b : {
                x <= f(z);
                y <= f(x);

                /*
                    dependencies:
                    x -> [z]
                    y -> [x]
                    sort: [z, x, y]
                */
            };
    }
    /*
       {
        x -> (m -> s, [z])
        y -> (m -> s, [z])
       }
       {
        z -> (m -> s, [x])
       }
        drop all signals at lower level?

        Map String -> (Set dependents -> Bool, Bool, result)
    */
}

implementation: 
func :: CtrlExpr -> [list of vars in scope] -> Either String (Map String val -> something, [vars it depends on])

*/
