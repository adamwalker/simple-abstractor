/*
STATE
dev_lba_low, dev_lba_hi, os_lba_low, os_lba_hi, dev_st, os_st

CLABEL
cont
ctag
write8_arg, 

ULABEL
utag
read_req_lba_low_arg, read_req_lba_hi_arg

*/
{
    dev_lba_low := case {
        cont==1 && ctag==0 && addr==0 : write8_arg;
        true                       : os_lba_low;
    };

    dev_lba_hi := case {
        cont==1 && ctag==0 && addr==1 : dev_lba_low;
        true                       : dev_lba_hi;
    };

    dev_sect := case {
        cont==1 && ctag==0 && addr==2 : write8_arg;
        true                       : dev_sect;
    };

    /*

    dev_sect_finite : {udma_m1, udma_m2, other}
    write8_arg_dev_sect_fin : same as above
    will introduce preds such as write8arg==udma_m1 etc

    dev_sect_finite := case {
        cont==1 && ctag==0 && addr==2 : write8_arg_dev_sect_fin;
        true                       : dev_sect_finite;
    };

    */

    os_lba_low := case {
        cont==0 && utag==0 : read_req_lba_low_arg;
        true             : os_lba_low;
    };

    os_lba_hi := case {
        cont==0 && utag==0 : read_req_lba_hi_arg;
        true             : os_lba_hi;
    };

    dev_st := case {
        dev_st==0 : case {
            cont==1 && ctag==1 && addr==3  : 1;
            cont==0 && utag==1            : 2; //dev_impossible
            true                        : 0;
        };
        dev_st==1 : case {
            cont==0 && utag==1            : 0;
            true                        : 1;
        };
    };

    class_udma_mode_set := case {
        dev_st==0 && cont==1 && ctag==1 && addr==4 : 1;
        true                                    : 0;
    };

    class_udma_mode_val <= dev_sect;

    //class_sect_written <= if(utag==1){1}else{0};
    class_lba_low <= dev_lba_low;

    /*
    if(utag==1){
        {
            var1 <= 1;
            var2 <= 2;
            var3 := if(var1==var2) {1} else {0};
        }
    } else {
        {
            var1 <= 0;
            var2 <= 3;
            var3 := if(var1==var2) {1} else {0};
        }
    };
    */

    os_st := case {
        os_st==0 : case {
            cont==0 && class_sect_written==1 : 2; //error
            cont==0 && utag==2            : 1;
            true                        : 0;
        };
        os_st==1 : case {
            cont==0 && class_sect_written==1 && class_lba_low!=os_lba_low : 2;
            cont==0 && class_sect_written==1 && class_lba_low==os_lba_low : 0;
            true                                                     : 1;
        };
   };
}

/*
    goal : os_st==0 || dev_st==dev_impossible
*/

/*

--finite domain abstraction

os_st==0 -> 

case {
    os_st==0 : case {
        !cont && utag==1 : !"os_st==0";
        !cont && utag==2 : "os_st==0"
        ...
    };
    ...
}

--or

reg_sect := case {
    tag==write8 : wval8;
    true        : reg_sect;
}


=====>

pred : reg_sect==os_sect 

case {
    tag==write8 : "reg_sect'==wval8";
    true        : "reg_sect'==reg_sect";
}

eventually we get: os_sect==wval8

pred : reg_sect==8 //const = some command

case {
    tag==write8 : "wval8==8";
    true        : "reg_sect==8";
}

new preds: os_sect==wval8, wval8_8==8, reg_sect==8

new new preds: os_sect==8


what if:

x==l, y==l, x==z, y==z, (x, y, z) are state preds
first pass:
x==y, add constraints on this, x==z and x==y


--refinement

forall (os_st, cont, utag).
   os_st==0 && !(cont && utag==2) -> os_st'==0
|| os_st==1 && !cont && utag==1   -> os_st'==0

pick one state predicate -> os_st==0 or os_st==1

what now? We dont know if utag is available. Cpre says - forall utag and exists utag. Avl(utag) is implicit

dev_st==0 && !cont && utag==1 -> dev_st==dev_impossible
not allowed = dev_st==0 && !cont && utag==1

--finding finite subdomain:

search for all preds
eg if variable is x and find x==1, x==5...
what if dev_sect has eq preds as well? - ignore
what if new preds appear when combining labels? 
    eg l==8, l==x, x==8


variables have some possibly infinite domain with some concrete elements eg 0, 1, 2, False, True

we want update functions for:
x==y 
x==c where c is an element of xs domain
maybe entire variable if it comes from a small domain and is only assigned similar variables

atoms in our language are: x==y, x==c and x which is the same as x/=0

depends on variable representation
x==c : entire domain of x represented?
x==y : entire domain of x and y represented?

conj {
    // Map String -> (abs1, passthrough)
    // map has z, x, y
    z <= f(..);
    --z <= f(x);
    case {
        a : {
                // Map String -> (ab1, passthrough)
                // map has x, y
                /*
                    a : maintain Map String -> CtrlExpr as source of signal
                    b : maintain a Map String -> (ab1, passthrough) as memo table
                    go through all signals assigned at this level or lower
                    
                */
                x <= f(y, z);
                y <= f(z)

                /*
                    dependencies: 
                    x -> [y, z]
                    y -> [z]
                    sort: [z, y, x]
                    Map String stuff -> (Map String stuff, [signals it depends on])
                */
            };
        b : {
                x <= f(z);
                y <= f(x);

                /*
                    dependencies:
                    x -> [z]
                    y -> [x]
                    sort: [z, x, y]
                */
            };
    }
    /*
       {
        x -> (m -> s, [z])
        y -> (m -> s, [z])
       }
       {
        z -> (m -> s, [x])
       }
        drop all signals at lower level?

        Map String -> (Set dependents -> Bool, Bool, result)
    */
}

implementation: 
func :: CtrlExpr -> [list of vars in scope] -> Either String (Map String val -> something, [vars it depends on])

*/
/*

STATE
st, st2
LABEL
x

{
    case {
        x==write8 : {
            st := 0;
            st2 := 1;
        }
        x==something : {
            st := x;
            st2 := y;
        }
        default :{
            st :=
            st2 :=
        }
    };

    if(cond) {
    } else {
    };

    asdgf:=8;
}

x==write8 -> "st==st2"'==false
x==something -> ("st==st2"' == "x==y")

DISJ {
    cond && (st'==5);
    cond2 && (st'==6);
}


case {
    l==1 : {
        a := x
        b := b
        c := c
    }
    ..
    ....
}

a := case {
    l==1 : x
    default : a
}

=======

signal class_event;
signal class_arg : int;

case {
    ... : {
        something;
        class_event(class_arg);
        class_Event <= true
        class_arg <= 5;
    }
    ... : {
        something else;
        class_Event <= false
    }
}

====OS

os_st : = case {
    os_st==waiting : {
        case {
            class_Event : os_done;
            default waiting;
        }
    }
}

*/
